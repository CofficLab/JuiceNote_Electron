<toc></toc><h1 id="heading-1">通道</h1><h2 id="heading-2">简单例子</h2><code-tab titles="命名函数,监视通道元素个数与容量,监视协程数量,匿名函数" current="3"><pre index="1"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)

    go sayHello(ch)
    
    fmt.Print(&lt;-ch)
}

func sayHello(ch chan string) {
    ch&lt;-"Hello"
}</code></pre><pre index="2"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)
    fmt.Println("通道初始化后："+printChannel(ch))

    go sayHello(ch)
    fmt.Println("子协程启动后："+printChannel(ch))
    
    fmt.Println(&lt;-ch)
    fmt.Println("读取通道数据后："+printChannel(ch))
}

func sayHello(ch chan string) {
    fmt.Println("往通道写数据前："+printChannel(ch))
    ch&lt;-"Hello"
    fmt.Println("往通道写数据后："+printChannel(ch))
}

func printChannel(ch chan string) string {
    return fmt.Sprintf("通道的容量是 %d 通道现有元素个数 %d",cap(ch),len(ch))
}</code></pre><pre index="3"><code language="go" run="1">package main 
import "fmt"
import "runtime"

func main() {
    ch := make(chan string)
    printNumGoroutine("通道初始化后")

    go sayHello(ch)
    printNumGoroutine("子协程启动后")
    
    fmt.Println(&lt;-ch)
    printNumGoroutine("读取通道数据后")
}

func sayHello(ch chan string) {
    ch&lt;-"Hello"
}

func printNumGoroutine(milestone string) {
    fmt.Printf(milestone+"协程个数 %d \n",runtime.NumGoroutine())
}</code></pre><pre index="4"><code language="go" run="1">package main
import "fmt"

func main() {
    messages := make(chan string)

    go func() { messages &lt;- "ping" }()

    msg := &lt;-messages
    fmt.Print(msg)
}</code></pre></code-tab><h2 id="heading-3">死锁</h2><chat position="start"><p>例子1：通道必须将两个协程联系起来，没有接收者不会通过编译</p></chat><chat position="start"><p>例子2：自己给自己发送消息，可以通过编译</p></chat><code-tab titles="例子1,例子2" current="1"><pre index="1"><code language="go" run="1">package main 

func main() {
    ch := make(chan string)
    ch&lt;-"Hello"
}</code></pre><pre index="2"><code language="go" run="1">package main
import "fmt"

func main() {
    messages := make(chan string)

    messages &lt;- "ping"

    fmt.Println(&lt;-messages)
    fmt.Print("The End")
}</code></pre></code-tab><h2 id="heading-4">缓冲</h2><code-tab titles="正常情况,主进程忙的情况,带缓冲区
,协程同步" current="2"><pre index="1"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)
    
    go clear(ch)

    fmt.Print("收到")
}

func clear(ch chan string) {
    ch&lt;-"101清理完成"
}</code></pre><pre index="2"><code language="go" run="1">package main 
import "fmt"
import "time"

func main() {
    ch := make(chan string)
    
    go clear(ch)

    time.Sleep(time.Second * 2)
    fmt.Print("收到")
}

func clear(ch chan string) {
    ch&lt;-"101清理完成"
    fmt.Print("清理下一个房间")
}</code></pre><pre index="2"><code language="go" run="1">package main

import "fmt"

func main() {
    messages := make(chan string, 2)

    messages &lt;- "buffered"
    messages &lt;- "channel"

    fmt.Println(&lt;-messages)
    fmt.Print(&lt;-messages)
}</code></pre><pre index="3"><code language="go" run="NaN">package main
import "fmt"
import "time"

func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    done &lt;- true
}

func main() {
    done := make(chan bool, 1)
    go worker(done)

    &lt;-done
    fmt.Print("The End")
}</code></pre></code-tab><h2 id="heading-5">Select</h2><chat position="start"><p>select 是专门为 channel 设计的关键词，看名字就知道是应用于多个 channel 的场景</p></chat><code-tab titles="不用select,用select,两个子协程耗时相同" current="0"><pre index="1"><code language="go" run="1">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    // 两个协程同时运行
    go sayOne(c1)
    go sayTwo(c2)

    // 这样永远先输出 sayOne 的结果
    // 即使 sayTwo 是先完成的
    fmt.Println(&lt;-c1)
    fmt.Println(&lt;-c2)

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}

func sayOne(ch chan string) {
    time.Sleep(2 * time.Second)
    ch&lt;-"one"
}

func sayTwo(ch chan string) {
    time.Sleep(1 * time.Second)
    ch&lt;-"two"
}</code></pre><pre index="2"><code language="go" run="1">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    go sayOne(c1)
    go sayTwo(c2)

    // 这段代码的for语句的作用是执行两次select语句，
    // 有消息则打印，没消息则阻塞等待。
    for i := 0; i &lt; 2; i++ {
        // select 会一直等到有一条消息
        select {
        case msg1 := &lt;-c1:
            fmt.Println(msg1)
        case msg2 := &lt;-c2:
            fmt.Println(msg2)
        }

        // 取出了1条消息，本次循环结束
    }

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}

func sayOne(ch chan string) {
    time.Sleep(2 * time.Second)
    ch&lt;-"one"
}

func sayTwo(ch chan string) {
    time.Sleep(1 * time.Second)
    ch&lt;-"two"
}</code></pre><pre index="2"><code language="go" run="1">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    go sayOne(c1)
    go sayTwo(c2)

    // 两个子协程耗时相近，都有可能先输出 
    // 运行很多次，会出现先输出 sayTwo 结果的情况 
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(msg1)
        case msg2 := &lt;-c2:
            fmt.Println(msg2)
        }
    }

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}

func sayOne(ch chan string) {
    time.Sleep(1 * time.Second)
    ch&lt;-"one"
}

func sayTwo(ch chan string) {
    time.Sleep(1 * time.Second)
    ch&lt;-"two"
}</code></pre></code-tab><p>select的规则：</p><ul class="m-0 p-0"><li class="m-0 p-0"><p>只能用于通道操作</p></li><li class="m-0 p-0"><p>每一个case必须是通道操作，要么发送，要么接收</p></li><li class="m-0 p-0"><p>同时监听所有通道，监听到就执行</p></li><li class="m-0 p-0"><p>如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码</p></li></ul>