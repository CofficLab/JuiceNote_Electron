<toc></toc><h1 id="heading-1">通道</h1><h2 id="heading-2">简单例子</h2><code-tab titles="例子1,监视通道元素个数与容量,监视协程数量,例子2" current="0"><pre index="1"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)

    go sayHello(ch)
    
    fmt.Print(&lt;-ch)
}

func sayHello(ch chan string) {
    ch&lt;-"Hello"
}</code></pre><pre index="2"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)
    fmt.Println("通道初始化后："+printChannel(ch))

    go sayHello(ch)
    fmt.Println("子协程启动后："+printChannel(ch))
    
    fmt.Println(&lt;-ch)
    fmt.Println("读取通道数据后："+printChannel(ch))
}

func sayHello(ch chan string) {
    fmt.Println("往通道写数据前："+printChannel(ch))
    ch&lt;-"Hello"
    fmt.Println("往通道写数据后："+printChannel(ch))
}

func printChannel(ch chan string) string {
    return fmt.Sprintf("通道的容量是 %d 通道现有元素个数 %d",cap(ch),len(ch))
}</code></pre><pre index="3"><code language="go" run="1">package main 
import "fmt"
import "runtime"

func main() {
    ch := make(chan string)
    printNumGoroutine("通道初始化后")

    go sayHello(ch)
    printNumGoroutine("子协程启动后")
    
    fmt.Println(&lt;-ch)
    printNumGoroutine("读取通道数据后")
}

func sayHello(ch chan string) {
    ch&lt;-"Hello"
}

func printNumGoroutine(milestone string) {
    fmt.Printf(milestone+"协程个数 %d \n",runtime.NumGoroutine())
}</code></pre><pre index="4"><code language="go" run="1">package main
import "fmt"

func main() {
    messages := make(chan string)

    go func() { messages &lt;- "ping" }()

    msg := &lt;-messages
    fmt.Print(msg)
}</code></pre></code-tab><h2 id="heading-3">死锁</h2><code-tab titles="例子1,例子2" current="0"><pre index="1"><code language="go" run="1">package main 

func main() {
    ch := make(chan string)
    ch&lt;-"Hello"
}</code></pre><pre index="2"><code language="go" run="1">package main
import "fmt"

func main() {
    messages := make(chan string)

    go func() { messages &lt;- "ping" }()

    fmt.Print("The End")
}</code></pre></code-tab><h2 id="heading-4">缓冲</h2><code-tab titles="正常情况,主进程忙的情况,带缓冲区
,协程同步" current="3"><pre index="1"><code language="go" run="1">package main 
import "fmt"

func main() {
    ch := make(chan string)
    
    go clear(ch)

    fmt.Print("收到")
}

func clear(ch chan string) {
    ch&lt;-"101清理完成"
}</code></pre><pre index="2"><code language="go" run="1">package main 
import "fmt"
import "time"

func main() {
    ch := make(chan string)
    
    go clear(ch)

    time.Sleep(time.Second * 2)
    fmt.Print("收到")
}

func clear(ch chan string) {
    ch&lt;-"101清理完成"
    fmt.Print("清理下一个房间")
}</code></pre><pre index="2"><code language="go" run="NaN">package main

import "fmt"

func main() {
    messages := make(chan string, 2)

    messages &lt;- "buffered"
    messages &lt;- "channel"

    fmt.Println(&lt;-messages)
    fmt.Print(&lt;-messages)
}</code></pre><pre index="3"><code language="go" run="NaN">package main
import "fmt"
import "time"

func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    done &lt;- true
}

func main() {
    done := make(chan bool, 1)
    go worker(done)

    &lt;-done
    fmt.Print("The End")
}</code></pre></code-tab><h2 id="heading-5">Select</h2><code-tab titles="使用select,不用select,两个子协程耗时相同" current="1"><pre index="1"><code language="go" run="NaN">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 &lt;- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 &lt;- "two"
    }()

    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println("received", msg1)
        case msg2 := &lt;-c2:
            fmt.Println("received", msg2)
        }
    }

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}</code></pre><pre index="2"><code language="go" run="NaN">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 &lt;- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 &lt;- "two"
    }()

    msg1 := &lt;-c1
    fmt.Println("received", msg1)
    msg2 := &lt;-c2
    fmt.Println("received", msg2)

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}</code></pre><pre index="2"><code language="go" run="NaN">package main
import "fmt"
import "time"

func main() {
    start := time.Now()

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 &lt;- "one"
    }()
    go func() {
        time.Sleep(1 * time.Second)
        c2 &lt;- "two"
    }()
    
    for i:=0;i&lt;2;i++ {
        select {
            case msg1 := &lt;-c1:
                fmt.Println("received", msg1)
            case msg2 := &lt;-c2:
                fmt.Println("received", msg2)
        }
    }

    fmt.Printf("耗时 %v", time.Now().Sub(start))
}</code></pre></code-tab><chat position="start"><p>select 是专门为 channel 设计的关键词，看名字就知道是应用于多个channel 的场景</p></chat><p>select的规则：</p><ul class="m-0 p-0"><li class="m-0 p-0"><p>只能用于通道操作</p></li><li class="m-0 p-0"><p>每一个case必须是通道操作，要么发送，要么接收</p></li><li class="m-0 p-0"><p>同时监听所有通道，监听到就执行</p></li><li class="m-0 p-0"><p>如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码</p></li></ul>