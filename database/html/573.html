<toc></toc><h1 id="heading-1">分布式锁</h1><h2 id="heading-2">场景</h2><p>有1000个子工作单元，每个子工作单元完成工作后，将计数器加一，最终计数器的值应该是1000。</p><h2 id="heading-4">单机程序</h2><h3 id="heading-5">不加锁</h3><pre index="1"><code language="" run="1">package main
import "sync"
import "fmt"

var counter int
var wg sync.WaitGroup

func main() {
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go work()
    }

    wg.Wait()
    fmt.Print(counter)
}

func work() {
    defer wg.Done()

    counter++
}</code></pre><p>启动1000个子协程，每个协程将counter加1，期望输出1000，但实际上会小于1000。</p><p>因为协程要先读出counter的值，然后计算加1后的值。</p><p>在这个计算过程中，counter的值可能被其他协程改变了。</p><p>counter++不是一个原子性操作。counter++实际上分为三个步骤:</p><p>1. 获取counter的值<br>2. 对该值加1<br>3. 将加1后的值存回counter在多核CPU下,多个goroutine可能会同时执行步骤1,得到counter的值。此时,某个goroutine完成步骤2和3,将值+1并存回counter。其他goroutine继续执行步骤2和3,使用的还是之前得到的counter值,导致最后结果错误。</p><h3 id="heading-6">加锁且阻塞</h3><p>sync.Mutex 是一个互斥锁，确保同一时间只有一个 goroutine 可以访问被 mutex 保护的共享变量。</p><p>Mutex是mutual exclusion的缩写。</p><pre index="1"><code language="" run="1">package main
import "sync"
import "fmt"

var counter int
var wg sync.WaitGroup
var mutex = sync.Mutex{}

func main() {
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go work()
    }

    wg.Wait()
    fmt.Print(counter)
}

func work() {
    defer wg.Done()

    mutex.Lock()
    counter++
    mutex.Unlock()
}</code></pre><h3 id="heading-7">加锁但不阻塞</h3><p>在某些场景，我们只是希望一个任务有单一的执行者。而不像计数器场景一样，所有goroutine都执行成功。后来的goroutine在抢锁失败后，需要放弃其流程。这时候就需要trylock了。</p><pre index="1"><code language="go" run="1">package main
import "sync"
import "fmt"

var counter int
var wg sync.WaitGroup
var mutex = sync.Mutex{}

func main() {
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go work()
    }

    wg.Wait()
    fmt.Print(counter)
}

func work() {
    defer wg.Done()

    locked := mutex.TryLock()
    if locked {
        counter++
        mutex.Unlock()
    } else {
        fmt.Println("加锁失败")
    }
}</code></pre><h2 id="heading-8">Reidis的setnx</h2>