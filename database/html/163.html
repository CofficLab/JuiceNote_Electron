<toc></toc><h1 id="heading-1">defer</h1><official-link class="bg-cyan-800/20 p-4">https://go.dev/ref/spec#Defer_statements</official-link><h2 id="heading-2">概述</h2><p>一个 defer 语句就是一个普通的函数或方法调用。 defer 语句保证了不论是在正常情况下 (return 返回)， 还是非正常情况下 (发生错误，程序终止)，函数或方法都能够执行。</p><h2 id="heading-3">主要特性</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p>一个函数可定义多个 defer 语句</p></li><li class="m-0 p-0"><p>defer 表达式中的变量值在 defer 表达式定义时已经确定</p></li><li class="m-0 p-0"><p>defer 表达式可以修改函数中的命名返回值</p></li></ul><h2 id="heading-4">主要作用</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p>简化异常处理 ( 使用 defer + recover)，避免异常与控制流混合在一起 (try … catch … finally)</p></li><li class="m-0 p-0"><p>在 defer 做资源释放和配置重置等收尾工作</p></li></ul><h2 id="heading-5">语法规则</h2><p>如果 defer 函数只有一行语句，可以省略 func() { ... } 代码块，否则就需要用 func() { ... } 代码块包起来。</p><h2 id="heading-6">多个 defer 执行顺序</h2><p>如果一个函数中注册了多个 defer 函数，这些函数会按照 后进先出 的顺序执行 (和 栈 的出栈顺序一致)。 也就是最后注册的 defer 函数会第一个执行，而第一个注册的 defer 函数会最后执行。</p><p>当有多个 defer 行为被注册时，它们会以逆序执行(类似栈，即后进先出):</p><h2 id="heading-7">例子</h2><p>函数退出前打印字符</p><pre index="1"><code language="go" run="NaN">func copy(dst, src []Type) int</code></pre><p>关闭文件句柄</p><pre index="1"><code language="go" run="NaN">package main
import "fmt"

func main() {
    a := []int{1,2,3}
    b := []int{}
    c := make([]int, 7)
    d := make([]int, 2)
    e := make([]int, len(a))
    x := a

    copy(b,a)
    copy(c,a)
    copy(d,a)
    copy(e,a)

    fmt.Printf("%[1]p %[1]v\n", a)
    fmt.Printf("%[1]p %[1]v\n", x)
    fmt.Printf("%[1]p %[1]v\n", b)
    fmt.Printf("%[1]p %[1]v\n", c)
    fmt.Printf("%[1]p %[1]v\n", d)
    fmt.Printf("%[1]p %[1]v\n", e)
}</code></pre><p>多个 defer 函数</p><pre index="1"><code language="go" run="NaN">package main
import "fmt"

func A() {
    defer fmt.Println("第 1 个 defer 函数")

    defer func() { // 这里为了演示 func() { ... } 的语法
        defer fmt.Println("第 2 个 defer 函数")
    }()

    defer fmt.Println("第 3 个 defer 函数")

    fmt.Println("A 函数开始执行")
}

func main() {
    A()
}</code></pre><h2 id="heading-8">参考资料</h2><p>https://learnku.com/articles/74164</p>