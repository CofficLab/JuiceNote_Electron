<toc></toc><h1 id="heading-1">原子操作</h1><h2 id="heading-2">简介</h2><p>原子操作(atomic operation)是不会被线程调度机制打断的操作。这种操作一旦开始,就会继续运行直到结束,中间不会有任何 context switch。原子操作有以下几个特点:</p><p>1. 不可中断:一旦开始,运行直到结束。<br>2. 顺序一致性:多个线程并发执行时,每次执行结果与执行顺序相同。<br>3. 线程安全:可以由多个线程同时访问,并得到正确结果。</p><p>相比之下,非原子操作可能出现以下问题:</p><p>1. 数据竞争:多个线程同时访问导致最后结果错误。<br>2. 不确定性:每次执行结果无法确定。<br>3. 死锁:线程相互等待导致死锁。</p><h2 id="heading-3">例子1</h2><h3 id="heading-4">场景与问题</h3><p>一个典型的例子是自增操作x++。因为x++实际上包含读、改、写三个操作,不是原子的,所以在并发环境下会产生问题。</p><pre index="1"><code language="go" run="1">package main 
import "fmt"

var a int = 0

func inc() {
    a++
}

func main() {
    for i := 0; i &lt; 100; i++ {
        go inc() 
    }

    fmt.Print(a)
}</code></pre><h3 id="heading-5">解决方案1</h3><p>使用mutex进行同步</p><pre index="1"><code language="" run="1">package main

var mutex sync.Mutex
var x int = 0  

func inc() {
    mutex.Lock()
    x++
    mutex.Unlock()
}</code></pre><h3 id="heading-6">解决方案2</h3><p>使用原子操作</p><pre index="1"><code language="" run="1">import "sync/atomic"

var x int64 = 0

func inc() {
    atomic.AddInt64(&amp;x, 1) 
}</code></pre><h2 id="heading-7">常见的原子操作</h2><p>1. 自增/自减:像x++, ++x, x--,--x<br>2. 赋值:像x = y<br>3. CAS(Compare And Swap):比较并交换,像CAS(x, y, z)<br>4. 读:像LoadInt(), LoadPointer()<br>5. 写:像StoreInt(), StorePointer()Go语言中提供了sync/atomic包来支持原子操作。主要包括:- AddInt32/AddInt64/AddUint32/AddUint64:原子增加<br>- CompareAndSwapInt32/CompareAndSwapInt64:原子比较并交换<br>- LoadInt32/LoadInt64:原子读取<br>- StoreInt32/StoreInt64:原子存入使用这些函数可以实现对整数和指针的原子操作,解决并发安全问题而不需要使用锁。原子操作是保证并发安全的一种高效机制。理解什么是原子操作,及Go语言中的实现方式,有助于我们实现高效的并发程序。</p><h2 id="heading-8">如何判断是不是原子操作</h2><p>判断一个操作是否原子,主要取决于以下几个因素:1. 操作的数据类型。基本数据类型的操作更有可能是原子的,复杂数据类型的操作通常不是原子的。因为基本类型占用内存小,可以在一条CPU指令中完成,而复杂类型则不行。2. 操作的内存访问范围。如果一个操作只访问CPU缓存中的数据,那么更有可能是原子的。如果操作访问主内存,需要CPU与内存之间的通信,则难以保证原子性。3. CPU指令的范围。如果一个操作可以用一条或几条CPU指令表示,那么此操作有可能是原子的。如果需要大量指令协同完成,中间可被中断,则难以实现原子性。4. 编译器优化。编译器在优化代码时,有可能会改变操作的原子性。例如把一条复杂的指令优化为多条简单指令,这可能导致原本原子的操作变为非原子的。基于以上因素,我们可以通过以下方式判断一个操作的原子性:1. 操作的数据类型。基本整数类型的赋值,读取等操作通常是原子的。而复杂结构体的访问则不是。2. 操作的内存范围。仅访问CPU缓存的数据操作可能是原子的。而访问主内存的操作通常不是原子的。3. 操作可以表示为一条CPU指令。如果一个操作对应一条指令,那么这个操作有可能是原子的。反之则不太可能。4. 确认编译器是否会改变操作语义。需要检查编译后的汇编代码,确认操作是否仍表示为一条或少量指令。如果编译器做了过多优化导致语义变化,那么操作可能不是原子的。5. 查阅CPU/编译器文档。文档中有时会明确说明某些操作是否原子,这也是判断的一个可靠方式。6. 实测。在并发环境中实际测试这个操作,观察其是否出现数据竞争等并发问题。如果出现,那么很有可能不是一个原子操作。综上,判断一个操作的原子性需要结合操作语义、实现细节以及实际测试结果。理解什么是原子操作及如何判断,可以帮助我们更高效地解决并发问题。</p>