<toc></toc><h1 id="heading-1">原子操作 Atomic</h1><h2 id="heading-2">典型场景</h2><chat position="start"><p>我现在需要统计班级里12岁以上的小朋友的人数，请大家报数</p></chat><p></p><chat position="end"><p>1</p></chat><chat position="start"><p>2</p></chat><chat position="end"><p>2</p></chat><p>第二个小朋友和第三个小朋友同时看到了第一个小朋友发出的：1，各自的大脑开始思考：</p><ul class="m-0 p-0"><li class="m-0 p-0"><p>读：现在的数字是1</p></li><li class="m-0 p-0"><p>改：我需要加1，将其变成2</p></li><li class="m-0 p-0"><p>写：向群里发结果-&gt;2</p></li></ul><p>结果并不是我们期望的，因为出现了两个2。</p><p>用 Go 语言来表达上述场景：</p><pre index="1"><code language="go" run="1">package main 
import "fmt"
import "sync"

var count int = 0
var wg = sync.WaitGroup{}

func inc() {
    // 也可以简写成count++
    // 对计算机来说，实际上也是读、改、写三个步骤
    count = count + 1

    wg.Done()
}

func main() {
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go inc() 
    }

    // 等待所有子协程运行结束 
    wg.Wait()
    fmt.Print(count)
}</code></pre><p>多运行几次，最后的输出结果有可能会小于1000。</p><h2 id="heading-3">解决方案1</h2><p>使用mutex进行同步</p><pre index="1"><code language="" run="1">package main 
import "fmt"
import "sync"

var count int = 0
var wg = sync.WaitGroup{}
var mutex = sync.Mutex{}

func inc() {
    // 加锁，如果锁成功了则继续执行
    // 如果锁失败了则等待，直到成功
    // 相当于每个子协程先申请权限
    // 由mutext保证任一时刻只有一个子协程得到授权
    mutex.Lock()

    // 也可以简写成count++
    // 对计算机来说，实际上也是读、改、写三个步骤
    count++

    // 开锁
    mutex.Unlock()

    wg.Done()
}

func main() {
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go inc() 
    }

    // 等待所有子协程运行结束 
    wg.Wait()
    fmt.Print(count)
}</code></pre><h2 id="heading-4">解决方案2</h2><p>使用原子操作。</p><p>sync/atomic 包提供了低级的原子操作，用于实现并发安全。</p><pre index="1"><code language="" run="1">package main 
import "fmt"
import "sync"
import "sync/atomic"

var count int64 = 0
var wg = sync.WaitGroup{}

func inc() {
    atomic.AddInt64(&amp;count, 1) 

    wg.Done()
}

func main() {
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go inc() 
    }

    // 等待所有子协程运行结束 
    wg.Wait()
    fmt.Print(count)
}</code></pre><h2 id="heading-5">什么是原子操作</h2><p>原子操作(atomic operation)是不会被线程调度机制打断的操作。这种操作一旦开始,就会继续运行直到结束,中间不会有任何 context switch。原子操作有以下几个特点:</p><p>1. 不可中断:一旦开始,运行直到结束。<br>2. 顺序一致性:多个线程并发执行时,每次执行结果与执行顺序相同。<br>3. 线程安全:可以由多个线程同时访问,并得到正确结果。</p><p>相比之下,非原子操作可能出现以下问题:</p><p>1. 数据竞争:多个线程同时访问导致最后结果错误。<br>2. 不确定性:每次执行结果无法确定。<br>3. 死锁:线程相互等待导致死锁。</p><h2 id="heading-6">常见的原子操作</h2><p>sync/atomic包提供了针对基本数据类型(int32、int64、uint32、uint64等)的原子读写操作。常用的有:</p><ul class="m-0 p-0"><li class="m-0 p-0"><p>AddInt32/AddInt64/AddUint32/AddUint64:原子增加</p></li><li class="m-0 p-0"><p>CompareAndSwapInt32/CompareAndSwapInt64:原子比较并交</p></li><li class="m-0 p-0"><p>LoadInt32/LoadInt64:原子读取</p></li><li class="m-0 p-0"><p>StoreInt32/StoreInt64:原子写入这些操作可以在任何情况下(任意上下文切换)保证数据的并发安全访问。</p></li></ul><p>示例代码:</p><pre index="1"><code language="" run="1">package main
import "sync"
import "sync/atomic"
import "fmt"

var count int64 = 0
var wg = sync.WaitGroup{}

func inc() {
    atomic.AddInt64(&amp;count, 1)

    wg.Done()
}

func main() {
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go inc()
    }
    
    wg.Wait()
    fmt.Print(count)
} </code></pre><h2 id="heading-7">参考资料</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://mp.weixin.qq.com/s?__biz=MzI1MzI3OTA5OQ==&amp;mid=2247484161&amp;idx=1&amp;sn=e982920bb11d1e4d710eec7de77b4678&amp;chksm=e9d7ad15dea0240353fff7602cab745bc4bbeafa409ee68c9c3e395f4ab18fd2d505c6658bf3&amp;scene=178&amp;cur_album_id=2837102654035296258#rd">sync/atomic 设计与实现</a></p></li></ul>