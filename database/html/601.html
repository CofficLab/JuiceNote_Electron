<toc></toc><h1 id="heading-1">互斥锁 Mutex</h1><h2 id="heading-2">简介</h2><p>互斥锁用于保证同一时刻至多有一个协程访问共享资源。</p><h2 id="heading-3">例子</h2><code-tab titles="简洁版,详细版" current="0"><pre index="1"><code language="" run="1">package main 
import "sync"
import "fmt"

var mutex = sync.Mutex{}
var wg = sync.WaitGroup{}
var count int64 = 0

func inc() {
    mutex.Lock()  // 加锁
    count++
    mutex.Unlock() // 解锁

    wg.Done()
}

func main() {
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go inc()
    }
    
    wg.Wait()
    fmt.Print(count)
}</code></pre><pre index="2"><code language="" run="1">package main 
import "sync"
import "fmt"

var mutex = sync.Mutex{}
var wg = sync.WaitGroup{}
var count int64 = 0

func inc() {
    mutex.Lock()  // 加锁
    count++
    fmt.Println("当前count的值是", count)
    mutex.Unlock() // 解锁

    wg.Done()
}

func main() {
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go inc()
    }
    
    wg.Wait()
    fmt.Print(count)
}</code></pre></code-tab><p>这个例子启动100个goroutine去自增变量count,使用sync.Mutex保证同一时刻只有一个goroutine修改count的值。分析Mutex的作用:1. mutex.Lock()用于加锁,如果成功则继续执行,如果失败则阻塞等待。<br>2. 所以同一时刻只有一个goroutine可以获得锁并访问共享资源。<br>3. 其它试图加锁的goroutine会阻塞,直到锁被释放。<br>4. mutex.Unlock()用于释放锁,将阻塞的一个goroutine唤醒。<br>5. 所以每个goroutine会先申请锁,成功后自增count的值并释放锁。<br>6. 虽然有100个goroutine自增,但任意时刻只有一个在操作,所以最终count的值为100。如果不使用Mutex,直接使用count++,则最终结果很有可能不是100,因为多个goroutine有机会同时读写count的值,最终只有一个值会生效。所以Mutex的作用是:1. 实现对共享资源的互斥访问(互斥锁)。<br>2. 保证同一时刻只有一个goroutine进入临界区,访问共享数据。<br>3. 其它试图进入的goroutine会阻塞,等待当前goroutine退出临界区。<br>4. 确保共享资源的并发安全访问,保证操作的正确性。但是使用Mutex也会带来一定的性能损耗,因为锁的竞争会使部分goroutine阻塞。所以在编写并发程序时,需要权衡功能和性能,选择最合适的同步方式。</p><h2 id="heading-4">其他并发同步方式</h2><p>除Mutex外,Go还提供了其他并发同步方式:</p><ul class="m-0 p-0"><li class="m-0 p-0"><p>Channel:用于goroutine之间的同步通信</p></li><li class="m-0 p-0"><p>WaitGroup:用于goroutine同步等待</p></li><li class="m-0 p-0"><p>atomic:用于基本数据类型的原子操作熟练使用这些工具可以让我们的Go程序具有高效的并发执行能力。</p></li></ul><p>所以理解Mutex及其他同步方式的原理和应用场景是很重要的。Mutex是一种比较基本但也很有用的同步方式,理解它的工作机制能帮助我们写出正确并发程序。虽简单,但要运用自如还需要不断学习和实践。</p><h2 id="heading-5">参考资料</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://mp.weixin.qq.com/s/D9Zgh2pm6hqqbIOkefrNcw">sync.Mutex 设计与实现</a></p></li></ul>