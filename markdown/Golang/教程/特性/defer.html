<h1 id="heading-1">defer</h1><p>&lt;div class="o"&gt;https://go.dev/ref/spec#Defer_statements&lt;/div&gt;</p><h2 id="heading-2">概述</h2><p>一个 defer 语句就是一个普通的函数或方法调用。 defer 语句保证了不论是在正常情况下 (return 返回)， 还是非正常情况下 (发生错误，程序终止)，函数或方法都能够执行。</p><h2 id="heading-3">主要特性</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p>一个函数可定义多个 defer 语句</p></li><li class="m-0 p-0"><p>defer 表达式中的变量值在 defer 表达式定义时已经确定</p></li><li class="m-0 p-0"><p>defer 表达式可以修改函数中的命名返回值</p></li></ul><h2 id="heading-4">主要作用</h2><ul class="m-0 p-0"><li class="m-0 p-0"><p>简化异常处理 ( 使用 defer + recover)，避免异常与控制流混合在一起 (try … catch … finally)</p></li><li class="m-0 p-0"><p>在 defer 做资源释放和配置重置等收尾工作</p></li></ul><h2 id="heading-5">语法规则</h2><p>如果 defer 函数只有一行语句，可以省略 func() { ... } 代码块，否则就需要用 func() { ... } 代码块包起来。</p><h2 id="heading-6">多个 defer 执行顺序</h2><p>如果一个函数中注册了多个 defer 函数，这些函数会按照 后进先出 的顺序执行 (和 栈 的出栈顺序一致)。 也就是最后注册的 defer 函数会第一个执行，而第一个注册的 defer 函数会最后执行。</p><h2 id="heading-7">例子</h2><p>函数退出前打印字符</p><p>&lt;div class="run"&gt;&lt;/div&gt;</p><pre><code class="language-go">package main
import "fmt"

func A() {
    defer fmt.Println("A 函数执行完成")

    fmt.Println("A 函数开始执行")
}

func B() {
    defer fmt.Println("B 函数执行完成")

    fmt.Println("B 函数开始执行")
}

func main() {
    A()
    B()
}

</code></pre><p>关闭文件句柄</p><p>&lt;div class="run"&gt;&lt;/div&gt;</p><pre><code class="language-go">package main

import "fmt"
import "os"

func createFile(name string) *os.File {
    file, err := os.Create(name)
    if err != nil {
        panic(err)
    }
    return file
}

func writeFile(file *os.File) {
    n, err := file.WriteString("hello world")
    if err != nil {
        panic(err)
    } else {
        fmt.Printf("成功写入 %d 个字符\n", n)
    }
}

func closeFile(file *os.File) {
    err := file.Close()
    if err != nil {
        panic(err)
    }
}

func main() {
    file := createFile("/tmp/defer_test.txt")
    defer closeFile(file) // 获取到文件句柄后，第一时间注册 defer 函数

    writeFile(file)
}
</code></pre><p>多个 defer 函数</p><p>&lt;div class="run"&gt;&lt;/div&gt;</p><pre><code class="language-go">package main
import "fmt"

func A() {
    defer fmt.Println("第 1 个 defer 函数")

    defer func() { // 这里为了演示 func() { ... } 的语法
        defer fmt.Println("第 2 个 defer 函数")
    }()

    defer fmt.Println("第 3 个 defer 函数")

    fmt.Println("A 函数开始执行")
}

func main() {
    A()
}
</code></pre><h2 id="heading-8">参考资料</h2><p>&lt;div class="link"&gt;https://learnku.com/articles/74164&lt;/div&gt;</p>