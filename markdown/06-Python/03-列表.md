# 列表

列表是可变的，即可修改其内容。另外，列表有很多特有的方法。

## 函数 list

鉴于不能像修改列表那样修改字符串，因此在有些情况下使用字符串来创建列表很有帮助。 为此，可使用函数 list。

```python
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']
```

请注意，可将任何序列(而不仅仅是字符串)作为 list 的参数。

> 提示 要将字符列表(如前述代码中的字符列表)转换为字符串，可使用下面的表达式:
>
> ''.join(somelist) 其中 somelist 是要转换的列表。这到底是什么意思呢?3.4.3 节对此做了说明。

## 基本的列表操作

可对列表执行所有的标准序列操作，如索引、切片、拼接和相乘，但列表的有趣之处在于它 11 是可以修改的。本节将介绍一些修改列表的方式:给元素赋值、删除元素、给切片赋值以及使用

列表的方法。(请注意，并非所有列表方法都会修改列表。)

## 修改列表:给元素赋值

修改列表很容易，只需使用第 1 章介绍的普通赋值语句即可，但不是使用类似于 x = 2 这样的 赋值语句，而是使用索引表示法给特定位置的元素赋值，如 x\[1\] = 2。

```python
13 >>> x 14

>>> x = [1, 1, 1] >>> x[1] = 2

[1, 2, 1]
```

它实际上是一个类，而不是函数，但眼下，这种差别并不重要。

> 注意 不能给不存在的元素赋值，因此如果列表的长度为 2，就不能给索引为 100 的元素赋值。
>
> 要这样做，列表的长度至少为 101。请参阅本章前面的“None、空列表和初始化”一节。

## 删除元素

从列表中删除元素也很容易，只需使用 del 语句即可。

```python
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl'] >>> del names[2]
>>> names
['Alice', 'Beth', 'Dee-Dee', 'Earl']
```

注意到 Cecil 彻底消失了，而列表的长度也从 5 变成了 4。除用于删除列表元素外，del 语句还 可用于删除其他东西。你可将其用于字典乃至变量。

## 给切片赋值

切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。

```python
>>> name = list('Perl') >>> name
['P', 'e', 'r', 'l']
>>> name[2:] = list('ar') >>> name

['P', 'e', 'a', 'r']
```

从上述代码可知，可同时给多个元素赋值。你可能认为，这有什么大不了的，分别给每个元素赋值不是一样的吗?确实如此，但通过使用切片赋值，可将切片替换为长度与其不同的序列。

```python
>>> name = list('Perl')
>>> name[1:] = list('ython') >>> name
['P', 'y', 't', 'h', 'o', 'n']
```

使用切片赋值还可在不替换原有元素的情况下插入新元素。

```python
>>> numbers = [1, 5]
>>> numbers[1:1] = [2, 3, 4] >>> numbers
[1, 2, 3, 4, 5]
```

在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除 切片。

```python
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = [] >>> numbers
[1, 5]
```

你可能猜到了，上述代码与 del numbers\[1:4\]等效。现在，你可自己尝试执行步长不为 1(乃 至为负)的切片赋值了。

## 列表方法

方法是与对象(列表、数、字符串等)联系紧密的函数。通常，像下面这样调用方法:

方法调用与函数调用很像，只是在方法名前加上了对象和句点(第 7 章将详细阐述方法到底 是什么)。列表包含多个可用来查看或修改其内容的方法。

## append 方法

append 用于将一个对象附加到列表末尾。

```python
>>> lst = [1, 2, 3] >>> lst.append(4) >>> lst
[1, 2, 3, 4]
```

## 列表:Python 的主力

你可能心存疑虑，为何给列表取 lst 这样糟糕的名字，而不称之为 list 呢?我原本是可以这 样做的，但你可能还记得，list 是一个内置函数 1，如果我将前述列表命名为 list，就无法调用 这个函数。在特定的应用程序中，通常可给列表选择更好的名称。诸如 lst 等名称确实不能提供 任何信息。因此，如果列表为价格列表，可能应该将其命名为 prices、prices_of_eggs 或 pricesOfEggs。

另外请注意，与其他几个类似的方法一样，append 也就地修改列表。这意味着它不会返回修 改后的新列表，而是直接修改旧列表。这通常正是你想要的，但有时会带来麻烦。我将在本章后 面介绍 sort 时再回过头来讨论这一点。

## clear 方法

clear 就地清空列表的内容。

```python
>>> lst = [1, 2, 3] >>> lst.clear()
>>> lst
[]
```

这类似于切片赋值语句 lst\[:\] = \[\]。

## copy 方法

copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。

```python
>>> a = [1, 2, 3]
>>> b = a
>>> b[1] = 4 13 >>> a
[1, 4, 3]
```

要让 a 和 b 指向不同的列表，就必须将 b 关联到 a 的副本。

实际上，从 Python 2.2 起，list 就是类型，而不是函数了(tuple 和 str 亦如此)。有关这方面的完整说明，请参阅 9.3.2 节。

```python
>>> a = [1, 2, 3] >>> b = a.copy() >>> b[1] = 4
>>> a

[1, 2, 3]
```

这类似于使用 a\[:\]或 list(a)，它们也都复制 a。

## count 方法

count 计算指定的元素在列表中出现了多少次。

```python
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to')
2
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
>>> x.count(1)
2
>>> x.count([1, 2])
1
```

## extend

方法 extend 让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提 供给方法 extend。换而言之，你可使用一个列表来扩展另一个列表。

```python
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]
```

这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列(这里是 a)。 在常规拼接中，情况是返回一个全新的序列。

```python
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3]
```

如你所见，拼接出来的列表与前一个示例扩展得到的列表完全相同，但在这里 a 并没有被修 改。鉴于常规拼接必须使用 a 和 b 的副本创建一个新列表，因此如果你要获得类似于下面的效果， 拼接的效率将比 extend 低:

```python
>>> a = a + b
```

另外，拼接操作并非就地执行的，即它不会修改原来的列表。要获得与 extend 相同的效果， 可将列表赋给切片，如下所示:

```python
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a[len(a):] = b
>>> a
[1, 2, 3, 4, 5, 6]
```

这虽然可行，但可读性不是很高。

## index 方法

index 在列表中查找指定值第一次出现的索引。

```python
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knights.index('who')
4
>>> knights.index('herring')

Traceback (innermost last):
File "<pyshell>", line 1, in ?

knights.index('herring')
ValueError: list.index(x): x not in list
```

搜索单词'who'时，发现它位于索引 4 处。

```python
>>> knights[4]

'who'
```

然而，搜索'herring'时引发了异常，因为根本就没有找到这个单词。

## insert

方法 insert 用于将一个对象插入列表。

```
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
```

与 extend 一样，也可使用切片赋值来获得与 insert 一样的效果。

```python
>>> numbers = [1, 2, 3, 5, 6, 7] >>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
```

这虽巧妙，但可读性根本无法与使用 insert 媲美。

## pop

方法 pop 从列表中删除一个元素(末尾为最后一个元素)，并返回这一元素。

```python
>>>  x = [1, 2, 3]
>>>  x.pop() 3
>>>  x
[1, 2]
>>>  x.pop(0) 1
>>>  x [2]
```

注意 pop 是唯一既修改列表又返回一个非 None 值的列表方法。

使用 pop 可实现一种常见的数据结构——栈(stack)。栈就像一叠盘子，你可在上面添加盘子， 还可从上面取走盘子。最后加入的盘子最先取走，这被为后进先出(LIFO)。

push 和 pop 是大家普遍接受的两种栈操作(加入和取走)的名称。Python 没有提供 push，但可 使用 append 来替代。方法 pop 和 append 的效果相反，因此将刚弹出的值压入(或附加)后，得到的 栈将与原来相同。

```python
>>> x = [1, 2, 3]
>>> x.append(x.pop()) >>> x
[1, 2, 3]
```

提示 要创建先进先出(FIFO)的队列，可使用 insert(0,...)代替 append。另外，也可继续使 用 append，但用 pop(0)替代 pop()。一种更佳的解决方案是，使用模块 collections 中的 deque。有关这方面的详细信息，请参阅第 10 章。

## remove

方法 remove 用于删除第一个为指定值的元素。

```python
>>> x = ['to', 'be', 'or', 'not', 'to', 'be'] >>> x.remove('be')
>>> x
['to', 'or', 'not', 'to', 'be']

>>> x.remove('bee') Traceback (innermost last):

File "<pyshell>", line 1, in ? x.remove('bee')

ValueError: list.remove(x): x not in list
```

如你所见，这只删除了为指定值的第一个元素，无法删除列表中其他为指定值的元素(这里 是字符串'bee')。

请注意，remove 是就地修改且不返回值的方法之一。不同于 pop 的是，它修改列表，但不返 回任何值。

## reverse

方法 reverse 按相反的顺序排列列表中的元素(我想你对此应该不会感到惊讶)。

```python
>>> x = [1, 2, 3] >>> x.reverse() >>> x
[3, 2, 1]
```

注意到 reverse 修改列表，但不返回任何值(与 remove 和 sort 等方法一样)。

提示 如果要按相反的顺序迭代序列，可使用函数 reversed。这个函数不返回列表，而是返回 一个迭代器(迭代器将在第 9 章详细介绍)。你可使用 list 将返回的对象转换为列表。

```python
>>> x = [1, 2, 3]
>>> list(reversed(x)) [3, 2, 1]
```

## sort

方法 sort 用于对列表就地排序 1。就地排序意味着对原来的列表进行修改，使其元素按顺序 排列，而不是返回排序后的列表的副本。

```python
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.copy()
>>> y.sort()
>>> x 8 [4, 6, 2, 1, 7, 9]

>>> x = [4, 6, 2, 1, 7, 9] >>> x.sort()
>>> x
[1, 2, 4, 6, 7, 9]
```

前面介绍了多个修改列表而不返回任何值的方法，在大多数情况下，这种行为都相当自然(例 如，对 append 来说就如此)。需要强调 sort 的行为也是这样的，因为这种行为给很多人都带来了 困惑。在需要排序后的列表副本并保留原始列表不变时，通常会遭遇这种困惑。为实现这种目标， 一种直观(但错误)的方式是像下面这样做:

```python
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.sort() # Don't do this! >>> print(y)
None
```

鉴于 sort 修改 x 且不返回任何值，最终的结果是 x 是经过排序的，而 y 包含 None。为实现前述 目标，正确的方式之一是先将 y 关联到 x 的副本，再对 y 进行排序，如下所示:

```
>>> y
[1, 2, 4, 6, 7, 9]
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = sorted(x)
>>> x
[4, 6, 2, 1, 7, 9] 11
>>> y
[1, 2, 4, 6, 7, 9]

```

实际上，这个函数可用于任何序列，但总是返回一个列表。

```python
>>> sorted('Python')

['P', 'h', 'n', 'o', 't', 'y']
```

如果要将元素按相反的顺序排列，可先使用 sort(或 sorted)，再调用方法 reverse，也可使

用参数 reverse，这将在下一小节介绍。

1 多说一句，从 Python 2.3 起，方法 sort 使用的是稳定的排序算法。  
2 实际上，函数 sorted 可用于任何可迭代的对象。可迭代的对象将在第 9 章详细介绍。

## 高级排序

方法 sort 接受两个可选参数:key 和 reverse。这两个参数通常是按名称指定的，称为关键字 参数，将在第 6 章详细讨论。参数 key 类似于参数 cmp:你将其设置为一个用于排序的函数。然而， 不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个 键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数 key 设置为函数 len。

```python
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] >>> x.sort(key=len)
>>> x
['add', 'acme', 'aerate', 'abalone', 'aardvark']
```

对于另一个关键字参数 reverse，只需将其指定为一个真值(True 或 False，将在第 5 章详细介 绍)，以指出是否要按相反的顺序对列表进行排序。

```python
>>> x = [4, 6, 2, 1, 7, 9] >>> x.sort(reverse=True) >>> x
[9, 7, 6, 4, 2, 1]
```

函数 sorted 也接受参数 key 和 reverse。在很多情况下，将参数 key 设置为一个自定义函数很有 用。第 6 章将介绍如何创建自定义函数。
